[
  {
    "id": 1,
    "title": "Redux",
    "date": "March 15, 2024",
    "coverImage": "",
    "description": [
      {
        "title": "What is Redux?",
        "content": "Redux is a state container that consistently holds the JavaScript application's behavior across the client and server. In some components to pass data, we need to props drilling. But, as Redux is considered a central store, then props drilling is not needed. Every component accesses the data from the central store easily."
      },
      {
        "title": "Uses of Redux",
        "content": [
          "Redux makes the state predictable",
          "Redux is easily maintainable",
          "Redux is easy to test and also optimizes the performance of the application"
        ]
      },
      {
        "title": "Redux-Workflow",
        "content": {
          "store": "Central store from where all states are saved and managed. As usual, a reasonable application has only one store.",
          "Actions": "Actions are pure JavaScript objects that have specific properties. The property contains an action type and info that need to be updated in the state. Depending on the application a lot of actions happened.",
          "Reducers": "Reducers are pure JavaScript functions that act to update the state and return the new state. It takes the current value of a state, takes the action depending on the action type, and returns the new state."
        }
      },
      {
        "title": "What is redux Toolkit",
        "content": "The Redux store setup and the basic configuration to use in an application are similar. It is a waste of time matter to write the same script for different applications. Sometimes it's a possibility to make mistakes. In a bigger application, other packages may be needed to configure the Redux. Considering these matters, the needed packages and the basic configuration for the Redux setup are extracted, and build a new package, which is Redux Toolkit. In Redux Toolkit, the basic structure of Redux and its needed packages are included, which makes our code and folder structure more understandable and organized."
      }
    ]
  },
  {
    "id": 2,
    "title": "A Few Advance Concept of JavaScript",
    "date": "March 15, 2024",
    "coverImage": "",
    "description": [
      {
        "title": "Truthy and Falsy Value",
        "content": "Considering the boolean concept, the value expression is true is considered a truthy value, and which value expression is false is called a falsy value."
      },
      {
        "title": "Null vs Undefined",
        "content": "In JavaScript, undefined is a type and null is a value. When a variable is declared, but no value is assigned, then it returns undefined. As null is a value, it can assign to a variable."
      },
      {
        "title": "Double Equal (==) vs Triple Equal (===)",
        "content": "Both of the signs are comparison operators. The == is used to compare values, and the === is used to compare both values and types."
      },
      {
        "title": "Closure",
        "content": "Inside a function, if we return another function and if this function is called from outside, then the function creates a closure for the outside's function calling. If another function calls the above function, then the above function creates another closure for this function call. The above function stored a reference for each function call. And that is closure. It works by reference. For every new function, it creates new closures and stores a new reference."
      },
      {
        "title": "Bind, Call and Apply",
        "content": "When a method is defined in local scope, then it is accessible or usable only within the scope. But, if we want to use this method in another object, then we can use the method by calling the object and method like, objectName.methodName.bind(newObject) . Here, objectName is where the method exists, the methodName is the name of the method, and pass newObject as an argument where we want to bind the method. If we directly call the method from the object, then we need the call() method.objectName.methodName.call(newObject, argument1, argument2, ...)In the call() method, we pass the object where we want to use the method, and also pass the argument or arguments that are needed to the method. The call() and apply() methods are mostly similar with just one difference. In the call() method we passed the object that we want to use and passed the argument/s that are needed in the object. There the arguments are separated by a comma (,), but in the apply() method, we wrap all the arguments within an array except the object name."
      }
    ]
  }
]
